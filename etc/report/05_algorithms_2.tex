\section{Algorithm classes}

The algorithms studied and discussed in the theoretical section all share the same structure, so we decided to build an abstract class for a generic Gibbs sampling iterative BNP algorithm, the \verb|Algorithm| class:
\begin{verbatim}
template<template <class> class Hierarchy, class Hypers,
         class Mixture> class Algorithm
\end{verbatim}
The \verb|Algorithm| class contains a number of integer class members:
\begin{itemize}
	\item \verb|maxiter|, the cumulative number of algorithm iterations;
	\item \verb|burnin|, the number of initial iterations in the burn-in phase, which will be discarded;
	\item \verb|init_num_clusters|: data will be randomly initialized in cluster according to this number, while making sure there is at least one datum per cluster.
	Default value is equal to the number of data points, that is, one point per cluster;
\end{itemize}
These integer values, including the seed for the \verb|rng| object (of type \verb|std::mt19937|, a basic Mersenne Twister random number generator provided by the standard C++ library) and the \verb|n_aux| parameter that indicates the number of auxiliary blocks in \verb|Neal8|, are not present in the class constructor since they are usually left with their default values, though they can still be changed through their respective setters.
If no other values are provided, \verb|maxiter| is initialized to 1000, \verb|burnin| to 100, and \verb|n_aux| to 3, values that we have assessed as sufficient for a good approximation after performing several tests.
Note that changing these values after running the algorithm (see below for the \verb|run()| function) has no effect. \\
The class contains several data and values containers: %TODO arrivato qui
\begin{verbatim}
Eigen::MatrixXd data;
std::vector<unsigned int> cardinalities;
std::vector<unsigned int> allocations;
std::vector< Hierarchy<Hypers> > unique_values;
std::pair< Eigen::MatrixXd, Eigen::VectorXd > density;
Mixture mixture;
State best_clust;
\end{verbatim}

The matrix of row-vectorial data points is given as input to the class constructor by the user, as well as the number of clusters for the algorithm initialization. If it is not provided, it will be automatically set equal to the number of data points, thus starting the algorithm with one datum per cluster.

The algorithm will keep track of the labels representing assignments to clusters via the \verb|allocations| vector.
For instance, if one has \verb|allocations[5] = 2|, it means that datum number 5 is associated to cluster number 2.
Note that indexing for both data and clusters starts at zero, so this actually means that we have the sixth datum being assigned to the third cluster. 
In \verb|cardinalities| the cardinalities of the clusters are stored, while \verb|unique_values| is a vector of Hierarchy objects, which identify the clusters and in which the corresponding unique values are stored in the \verb|state|. \
The \verb|Algorithm| class constructor is the following:

\begin{verbatim}
Algorithm(const Hypers &hypers_, const Mixture &mixture_,
	const Eigen::MatrixXd &data_, const unsigned int init = 0) :
    mixture(mixture_), data(data_), init_num_clusters(init) {
    Hierarchy<Hypers> hierarchy( std::make_shared<Hypers>(hypers_) );

    	if(hierarchy.is_multivariate() == false && data.cols() > 1){
        	std::cout << "Warning: multivariate data supplied to " <<
            	"univariate hierarchy. The algorithm will run " <<
                "correctly, but all data rows other than the first" <<
                "one will be ignored" << std::endl;
        }
        if(data.rows() == 0){
            init_num_clusters = 1;            
        }
        if(init_num_clusters == 0){
            // If not provided, standard initializ.: one datum per cluster
            std::cout << "Warning: initial number of clusters will be " <<
                "set equal to the data size (" << data.rows() << ")" <<
                std::endl;
            init_num_clusters = data.rows();
        }

        // Initialize hierarchies for starting clusters
        for(size_t i = 0; i < init_num_clusters; i++){
            unique_values.push_back(hierarchy);
        }
}

 \end{verbatim}
After dimensional checks and the initial number of clusters setting, if not provided, the \verb|unique_values| vector is initialized with empty \verb|Hierarchy| objects, while \verb|cardinalities| and \verb|allocations| with null values. They are filled with proper values when the algorithm is run.
The run() method, which is inherited from all derived classes, sharing the same general structure, is as follows:

TODO constructors

\begin{verbatim}

void step(){
    sample_allocations();
    sample_unique_values();
    sample_weights();
    update_hypers();
}

void run(BaseCollector* collector){
    initialize();
    unsigned int iter = 0;
    collector->start();
    while(iter < maxiter){
        step();
        if(iter >= burnin){
          save_state(collector, iter);
        }
        iter++;
    }
    collector->finish();
    }
    
\end{verbatim}

The BNP algorithm generates a Markov chain on the clustering of the provided data running multiple iterations of the same step.

\verb|initialize()| creates \verb|num_clusters| clusters and randomly assigns each datum to one of them, while making sure that each cluster contains at least one.
	This assignment is done through changing \verb|allocations| components, as explained earlier.

Steps are further split into substeps, each of which updates specific values of the state of the Markov chain, which is composed of the allocations vector and the unique values vector. Substeps are then overridden in the specific derived classes.

In particular, among the studied algoritmhs, only the blocked Gibbs algorithm exploits the \verb|sample_weights()| function. Moreover, \verb|update_hypers()| has an effect  when the hyperparameters are not fixed.

The collector input and \verb|start|, \verb|save_state| and \verb|finish| functions concern the saving of the chain states, which we will discuss later in the Collectors section.
We have implemented in particular the neal2 and neal8 derived algorithms, leaving in the \verb|step| all the substeps for a possible addition of other algorithms.




\subsection{\texttt{Neal2}}

As discussed in section \ref{neal2}, this algorithm exploits conjugacy, thus the class requires specifically implemented hierarchies, in which the marginal distribution of the data with respect to $\boldsymbol\theta$ is provided in closed form.
In our case, the Normal-NIG and Normal-NW specializations for the \verb|Neal2| template class were implemented.
\verb|Neal2| class constructor simply call \verb|Algorithm| constructor.
Afterwards the \verb|Neal2| class implements the substeps of the \verb|run| in the following manner:

\begin{itemize}

	\item In \verb|sample_allocations()|, a loop is performed over all observations $i=1:n$.
	The vector \verb|cardinalities| is filled at first, with \verb|cardinalities[j]| being the cardinality of cluster $j$.
	Then, the algorithm mandates that \verb|datum = data.row(i)| be moved to another cluster;
	A vector \verb|probas| with \verb|n_clust| components if \verb|datum| belongs to a cluster that is a singleton, or with \verb|n_clust+1| otherwise, is filled with the probabilities of each $\boldsymbol\phi$ being extracted, in line with (\ref{probasneal2}).
	Computations involve the \verb|cardinalities| vector, the mass probabilities defined by the \verb|Mixture|, the likelihood \verb|like()| evaluated in \verb|datum| to compute the probability of being assigned to an already existing cluster and \verb|eval_marg()| to compute the probability of being assigned to a newly generated cluster. Then, the new value for \verb|allocations[i]| is randomly drawn according to the computed \verb|probas|.
	Finally, four different cases of updating \verb|unique_values| and \verb|cardinalities| are handled separately, depending on whether the old cluster was a singleton or not and whether \verb|datum| is assigned to a new cluster.
	Indeed, in such a case, a new $\boldsymbol\phi$ value for it must be generated, and this must be handled differently by the code if an old singleton cluster was just destroyed (as the new cluster must take its former place).
	Depending on the case, clusters are either unchanged, increased by one, decreased by one, or moved around.
	
	\item In \verb|sample_unique_values()|, for each cluster $j$, their $\boldsymbol\phi$ values are updated through the \verb|sample_given_data()| function, which takes as argument the vector \verb|curr_data| of data points which belong to cluster $j$.
	Since we only keep track of clusters via their labels in \verb|allocations|, we do not have a vector of actual data points stored for each cluster.
	Thus we must fill, before the loop on $j$, a matrix \verb|clust_idxs| whose column $k$ contains the index of data points belonging to cluster $k$.
	\verb|clust_idxs| is then used in the $j$ loop to fill \verb|curr_data| with the actual data points of cluster $j$.

\end{itemize}


\subsection{\texttt{Neal8}}

Being Neal's algorithm 8 a generalization of Neal's algorithm 2 which works for any hierarchical model, even non-conjugate ones, it adds adjustments in the allocation sampling phase to circumvent non-conjugacy.
However, the unique values sampling phase remains unchanged. For this reason \verb|Neal8| is built as a derived class from \verb|Neal2|.

In addition to the members defined in Algorithm, the following are added in Neal8 class:
\begin{verbatim}
unsigned int n_aux = 3;
std::vector<Hierarchy<Hypers>> aux_unique_values;
\end{verbatim}
These are related to the auxiliary blocks. In particular the number of auxiliary blocks is automatically set equal to 3 with the possibility to change the default value with the corresponding setter.
Therefore \verb|Neal8| class constructor add the initialization of the auxiliary blocks with empty \verb|Hierarchy| object as for the unique values:
\begin{verbatim}
Neal8(const Hypers &hypers_, const Mixture &mixture_,
    const Eigen::MatrixXd &data_, const unsigned int init = 0) :
    Neal2<Hierarchy, Hypers, Mixture>::Neal2(hypers_, mixture_, data_,
    init) {
    // Initialize auxiliary blocks
    for(size_t i = 0; i < n_aux; i++){
        aux_unique_values.push_back(this->unique_values[0]);
    }
}

\end{verbatim}



Relying on the algorithm described in section \ref{neal8}, we proceed to describe the implementation of \verb|sample_allocations()|.

As before, a loop is performed over all observations $i=1:n$ and \verb|cardinalities| is filled. Now, if the current cluster is a singleton, its $\boldsymbol\phi$ values are transferred to the first auxiliary block. Then, each auxiliary block (except the first one if the above case occurred) generates new $\boldsymbol\phi$ values via the hierarchy's \verb|draw()| function. Now a new cluster, that is, new $\boldsymbol\phi$ values, for \verb|datum| needs to be drawn. 	A vector \verb|probas| with \verb|n_clust+n_aux| components is filled with the probabilities of each $\boldsymbol\phi$ being extracted, in line with (\ref{neal8prob}). In this case computations involve also the auxiliary components. Then,as in \verb|Neal2|, the new value for \verb|allocations[i]| is randomly drawn according to the computed \verb|probas|. Finally, four different cases of updating \verb|unique_values| and \verb|cardinalities| are handled separately, depending on whether the old cluster was a singleton or not, and whether an auxiliary block or an already existing cluster was chosen as the new cluster for \verb|datum|.
