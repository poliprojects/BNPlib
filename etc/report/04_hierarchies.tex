%\part{Implementation}

\chapter{Implementation}
The purpose of BNPlib library is to provide tools to conduct data analysis through the application of the algorithms described above for the construction of the respective Markov chains and the use of these for density and clustering estimations.

BNPlib includes a set of algorithm classes, templetized with \verb|Hierarchy|, \verb|Hypers| and \verb|Mixture| classes to allow the use of algorithms with different hierarchies, hyperparameters related to the hierarchy and mixture models.

The library currently contains Neal's two algorithms, Neal2 to be used in case of conjugate priors and Neal8 in case this requirement is missing.

BNPlib depends on other libraries such as:
\begin{itemize}

\item \textbf{Stan Math}, a C++ template library for automatic differentiation of any order. It includes a range of built-in functions for probabilistic modeling, linear algebra, and equation solving.
	\begin{itemize}
			\item Eigen library, a template library for linear algebra : matrices, vectors, numerical solvers, and related algorithms;
			\item Boost library that provides support for tasks and structures such as linear algebra, pseudorandom number generation, multithreading, image processing, regular expressions, and unit testing;
			\item Intel Threading Building Blocks (TBB) library, to write parallel C++ programs that take full advantage of multicore performance;
			\item Sundials library, a suite of nonlinear and differential/algebraic equation solvers;
	\end{itemize}
	
\item \textbf{Eigen} library, required by Stan Math library and exploited to build sparse matrices. 

\item \textbf{Protocol Buffer} library, developed by Google, that provides a fast serialization mechanism for structured data and extensible code generators for different programming languages.

\end{itemize}
Using the Protocol Buffers library it was possible to create a Python interface. For the interface it is needed:
\begin{itemize}
\item \textbf{pybind11}, a header-only library that exposes C++ types in Python and vice versa.
\end{itemize}
and for tools implemented in the Python interface file, the followings are required:
\begin{itemize}
\item \textbf{NumPy} library, that provides high-performance multidimensional array objects, and tools for working with these arrays;
\item \textbf{SciPy}, a library containing modules for numerical integration, interpolation, optimization, linear algebra, and statistics;
\item \textbf{Scikit-learn}, a free machine learning library built on top of SciPy;
\item \textbf{Matplotlib}, a plotting library;
\end{itemize}


\section{Hierarchy classes}
First of all, we must describe the auxiliary classes that are used as parameters for the algorithms:
\begin{itemize}
	\item The \verb|BaseMixture| class, contain all information about the mixing part of the BNP algorithm, namely the way of weighing the insertion of data in old clusters vs the creation of new clusters. The class has methods that provide mass probabilities for the two aforementioned events. We implemented the \verb|BaseMixture| class as an abstract class, and two derived classes: the \verb|DirichletMixture| and the \verb|PitYorMixture|. The derived classes have its own parameters and could be extended by adding prior distributions on these.

	\item The \verb|Hypers| classes contain all information about the hyperparameters of the hierarchy, including their values (if fixed) or their prior distributions (if not). We implemented the \verb|HypersFixedNNIG| class, which contains fixed hyperparameters for an NNIG hierarchy, and the \verb|HypersFixedNNW| class for an NNW hierarchy. Both classes provide setters and getters for parameters with validity checks for the inserted values.
	
	\item The abstract template class \verb|HierarchyBase<Hypers>| represents a hierarchy object in a generic iterative BNP algorithm, that is, a single set of unique values with their own prior
distribution attached to it. These values are part of the Markov chain's
state chain which develops as the iterations of the algorithm increase, updating them providing the data related to the specific hierarchy and their prior distribution.
They are simply referred to as the state of the hierarchy. 

The class stores the current unique values in the protected member \verb|state|, a vector of parameter matrices.
Since the prior distribution for the state is often the same across multiple
different hierarchies, the hyperparameters object is accessed via a shared
pointer, stored as protected member, and this is why \verb|Hypers| is required as a template parameter for the class. 

	A \verb|HierarchyBase<Hypers>| class also contains methods to:
	\begin{itemize}
		\item evaluate the marginal distribution (provided it is known in closed form) and the log-likelihood in a given set of points, given the current \verb|state|;
		\item compute the posterior parameters with respect to a given set of observations;
		\item generate new values for the \verb|state| both according to its prior and to its posterior distribution;
		\item get and set class members, as with the other classes.
	\end{itemize}


The hierarchy classes we implemented that inherits from this class are the \verb|HierarchyNNIG| class, which represents the Normal Normal-InverseGamma hierarchy for univariate data, and the \verb|HierarchyNNW| class, which represents the Normal Normal-Wishart hierarchy for multivariate data.

In particular the \verb|state| in the \verb|HierarchyNNIG| class holds the values for $\boldsymbol\phi = (\mu,\sigma)$, i.e.  location and scale, while the \verb|HierarchyNNW| class stores $\boldsymbol\phi = (\boldsymbol\mu,\boldsymbol\Lambda)$, i.e. location and precison parameters.
The base class, as mentioned, contains the setter for the state, where itâ€™s called \verb|check_state_validity()|, specific for each hierarchy, that raises error if the state values are not valid w.r.t. their own domain.
The check is done only in \verb|set_state()|, and not in the functions that generate new values for the state, since are called several times during the running of the algorithms and a check is not necessary. TODO
Note that both hierarchies implemented are conjugate, thus marginals and
posterior distributions are available in closed form and Neal2 algorithm may be used. \
	
\end{itemize}

Probability distributions and random sampling were handled through the \verb|Stan| library, whilst the popular \verb|Eigen| library was exploited for the creation of the necessary matrix-like objects and the use of matrix-algebraic operations throughout the code.