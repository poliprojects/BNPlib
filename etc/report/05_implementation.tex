\chapter{Implementation}

The algorithms studied and discussed in the theoretical section all share the same structure, so we decided to build an abstract class for a generic Gibbs sampling iterative BNP algorithm, the \verb|Algorithm| class:
\begin{verbatim}
template<template <class> class Hierarchy, class Hypers,
         class Mixture> class Algorithm
\end{verbatim}
A template approach was used, to allow the use of the algorithm with all the combinations of \verb|Hierarchy|, \verb|Hypers|, and \verb|Mixture| classes, which we discussed in the previous section.



The \verb|Algorithm| class contains the following members:
\begin{verbatim}
unsigned int maxiter;
unsigned int burnin;
std::mt19937 rng; // random number generating engine
\end{verbatim}
These are the parameters of the method, and are rather self-explanatory.
Their values are initialized either via the constructors or the setters.
By default the number of iterations is initialized to 1000 while the number of burn-in iterations is initialized to 100, values that we have assessed as sufficient for a good approximation after performing several tests.

The data and values containers were implemented as follows:
\begin{verbatim}
Eigen::MatrixXd data;
unsigned int num_clusters;
std::vector<unsigned int> cardinalities;
std::vector<unsigned int> allocations;
std::vector<Hierarchy<Hypers>> unique_values;
Mixture mixture;
\end{verbatim}

The matrix of row-vectorial data points is given as input to the class constructor by the user, as well as the number of clusters for the algorithm initialization. If it is not provided, it will be automatically set equal to the number of data points, thus starting the algorithm with one datum per cluster.

The algorithm will keep track of the labels representing assignments to clusters via the \verb|allocations| vector.
For instance, if one has \verb|allocations[5] = 2|, it means that datum number 5 is associated to cluster number 2.
Note that indexing for both data and clusters starts at zero, so this actually means that we have the sixth datum being assigned to the third cluster. 
In \verb|cardinalities| the cardinalities of the clusters are stored, while \verb|unique_values| is a vector of Hierarchy objects, which identify the clusters and in which the corresponding unique values are stored in the \verb|state|.

The three vectors just described, initialized with null values and empty Hierarchy objects, are filled with proper values when the algorithm is run.
The run() method, which is inherited from all derived classes, sharing the same general structure, is as follows:

\begin{verbatim}

void step(){
    sample_allocations();
    sample_unique_values();
    sample_weights();
    update_hypers();
}

void run(BaseCollector* collector){
    initialize();
    unsigned int iter = 0;
    collector->start();
    while(iter < maxiter){
        step();
        if(iter >= burnin){
          save_state(collector, iter);
        }
        iter++;
    }
    collector->finish();
    }
    
\end{verbatim}

The BNP algorithm generates a Markov chain on the clustering of the provided data running multiple iterations of the same step.

\verb|initialize()| creates \verb|num_clusters| clusters and randomly assigns each datum to one of them, while making sure that each cluster contains at least one.
	This assignment is done through changing \verb|allocations| components, as explained earlier.

Steps are further split into substeps, each of which updates specific values of the state of the Markov chain, which is composed of the allocations vector and the unique values vector. Substeps are then overridden in the specific derived classes.

In particular, among the studied algoritmhs, only the blocked Gibbs algorithm exploits the \verb|sample_weights()| function. Moreover, \verb|update_hypers()| has an effect  when the hyperparameters are not fixed.

The collector input and \verb|start|, \verb|save_state| and \verb|finish| functions concern the saving of the chain states, which we will discuss later in the Collectors section.
We have implemented in particular the neal2 and neal8 derived algorithms, leaving in the \verb|step| all the substeps for a possible addition of other algorithms.




\section{\texttt{Neal2} algorithm}

As discussed in section \ref{neal2}, this algorithm exploits conjugacy, thus the class requires specifically implemented hierarchies, in which the marginal distribution of the data with respect to $\boldsymbol\theta$ is provided in closed form.
In our case, the Normal-NIG and Normal-NW specializations for the \verb|Neal2| template class were implemented.

The \verb|Neal2| class implements the substeps of the \verb|run| in the following manner:

\begin{itemize}

	\item In \verb|sample_allocations()|, a loop is performed over all observations $i=1:n$.
	The vector \verb|cardinalities| is first filled, with \verb|cardinalities[j]| being the cardinality of cluster $j$.
	The algorithm mandates that \verb|datum=data.row(i)| be moved to another cluster;
	A vector \verb|probas| with \verb|n_clust| components if \verb|datum| belongs to a cluster that is a singleton, or with \verb|n_clust+1| otherwise, is filled with the probabilities of each $\boldsymbol\phi$ being extracted, in line with (\ref{probasneal2}).
	Computations involve the \verb|cardinalities| vector, the mass probabilities defined by the \verb|Mixture|, the likelihood \verb|like()| evaluated in \verb|datum| to compute the probability of being assigned to an already existing cluster and \verb|eval_marg()| to compute the probability of being assigned to a newly generated cluster. Then, the new value for \verb|allocations[i]| is randomly drawn according to the computed \verb|probas|.
	Finally, four different cases of updating \verb|unique_values| and \verb|cardinalities| are handled separately, depending on whether the old cluster was a singleton or not and whether \verb|datum| is assigned to a new cluster.
	Indeed, in such a case, a new $\boldsymbol\phi$ value for it must be generated, and this must be handled differently by the code if an old singleton cluster was just destroyed (as the new cluster must take its former place).
	Depending on the case, clusters are either unchanged, increased by one, decreased by one, or moved around.
	
	\item In \verb|sample_unique_values()|, for each cluster $j$, their $\boldsymbol\phi$ values are updated through the \verb|sample_given_data()| function, which takes as argument the vector \verb|curr_data| of data points which belong to cluster $j$.
	Since we only keep track of clusters via their labels in \verb|allocations|, we do not have a vector of actual data points stored for each cluster.
	Thus we must fill, before the loop on $j$, a matrix \verb|clust_idxs| whose column $k$ contains the index of data points belonging to cluster $k$.
	\verb|clust_idxs| is then used in the $j$ loop to fill \verb|curr_data| with the actual data points of cluster $j$.

\end{itemize}


\section{\texttt{Neal8} algorithm}

Being Neal's algorithm 8 a generalization of Neal's algorithm 2 which works for any hierarchical model, even non-conjugate ones, it adds adjustments in the allocation sampling phase to circumvent non-conjugacy.
However, the unique values sampling phase remains unchanged. For this reason \verb|Neal8| is built as a derived class from \verb|Neal2|.

In addition to the members defined in Algorithm, the following are added in Neal8 class:
\begin{verbatim}
unsigned int n_aux = 3;
std::vector<Hierarchy<Hypers>> aux_unique_values;
\end{verbatim}
These are related to the auxiliary blocks. In particular the number of auxiliary blocks is automatically set equal to 3 with the possibility to change the default value with the corresponding setter.

Relying on the algorithm described in section \ref{neal8}, we proceed to describe the implementation of \verb|sample_allocations()|.

As before, a loop is performed over all observations $i=1:n$ and \verb|cardinalities| is filled. Now, if the current cluster is a singleton, its $\boldsymbol\phi$ values are transferred to the first auxiliary block. Then, each auxiliary block (except the first one if the above case occurred) generates new $\boldsymbol\phi$ values via the hierarchy's \verb|draw()| function. Now a new cluster, that is, new $\boldsymbol\phi$ values, for \verb|datum| needs to be drawn. 	A vector \verb|probas| with \verb|n_clust+n_aux| components is filled with the probabilities of each $\boldsymbol\phi$ being extracted, in line with (\ref{neal8prob}). In this case computations involve also the auxiliary components. Then,as in \verb|Neal2|, the new value for \verb|allocations[i]| is randomly drawn according to the computed \verb|probas|. Finally, four different cases of updating \verb|unique_values| and \verb|cardinalities| are handled separately, depending on whether the old cluster was a singleton or not, and whether an auxiliary block or an already existing cluster was chosen as the new cluster for \verb|datum|.

