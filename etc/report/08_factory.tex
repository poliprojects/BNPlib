\section{Algorithm factory}
In order to have the possibility of a runtime choice of the algorithm, we implemented the \verb|Factory| class.
An \emph{object factory} allows to choose at runtime one of several object types for a given variable, provided that these objects derive from a common abstract base class, whose name is passed as a template parameter with the alias \verb|AbstractProduct|.
An object factory is usually implemented as a singleton and stores a list of \emph{builders}, i.e. functions that each create a different kind of object, into the private \verb|storage| class member.
Each of these builders can be as simple as a function returning a smart pointer to a new instance, and has an identifier (e.g. a string) corresponding to the specific object they create: \verb|storage| is therefore an Identifier-Builder map.
In order to have the choice of creating one of multiple objects, \verb|storage| must first be filled with their corresponding builders; this can be done in a main file or in an appropriate separate utility function.
Since the constructors of the implemented algorithm classes may take different numbers of parameters as input, we chose to templatize the factory with a variadic template in addition to the \verb|AbstractProduct| type.
This allows passing any number of parameters of any type to the constructors of the objects. \\
Theoretically, it would be possible to use the same \verb|Factory| implementation file to create multiple factories which each produce different categories of objects, since templates specialized with different arguments (\verb|AbstractProduct|) are treated as different objects altogether.
However the abstract product, which in our case is one of two algorithms, is defined with specific hierarchy, mixture, and hyperparameters classes, all of which must be known at compile time.
Therefore one could not have different independent factories that each generate a piece of the model.
In order to choose every class at runtime, it would be required to add all possible combinations of algorithms, hierarchies, and mixtures to the \verb|storage|, so that all possible \verb|AbstractProduct|s are known at compile time.
This is possible with the current number of available objects, but as the library expands with new classes being added, this method would not scale well.
Therefore, at the moment only the choice of the algorithm type is available at runtime. \\
Another difficulty for full runtime choices is that the hyperparameters classes do not currently have a base class, since their implementations heavily depend on the hierarchy they support and therefore have little to no common structure.
