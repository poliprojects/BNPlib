\section{Collectors}\label{collectors}
After an algorithm is run, one may be interested in an estimate of the density given a grid of points, and/or in an identification of a partition through the clustering obtained in the algorithm, which we sometimes call ``best clustering'', in the sense we described in section \ref{chap-esimates-1}.
In any case we need to be able to save and to retrieve the information of each iteration of the algorithm, such as allocations and unique values, which characterize the state of the chain.
This values must therefore be stored in an appropriate data structure, preferably one which is independent of \verb|Algorithm|, so that we do not have to save the entire chain of \verb|State| objects as a member.
For this reason, we have implemented the collector classes.
A \emph{collector} is an external class meant to store the state of the Markov chain at all iterations as a list of \verb|State| objects.
Their implementation is based on the \verb|protobuf| (Protocol Buffers) library, which allows automatic generation of data-storing C++ classes by defining a class skeleton in the \verb|chain_state.proto| file located in the root folder.
This also allows easy interfacing with other programming languages such as R and Python. \\
We built the template for our collector classes as follows:
\begin{verbatim}
message Par_Col {
    repeated double elems = 1;
}

message Param {
    repeated Par_Col par_cols = 1;
}

message UniqueValues {
    repeated Param params = 1;
}

message State {
    repeated int32 allocations = 1;
    repeated UniqueValues uniquevalues = 2;
}
\end{verbatim}
Here \verb|message| and \verb|repeated| are the \verb|protobuf| equivalent of classes and vectors respectively, while the numbers 1 and 2 just act as identifiers for the fields in the messages.
The corresponding C++ and Python classes are automagically generated off of this skeleton via the \verb|protoc| compiler. \\
We have implemented two types of collectors: \verb|FileCollector| and \verb|MemoryCollector|, both of which are derived classes from the \verb|BaseCollector| abstract class.
The former saves the \verb|State| objects into appropriate binary files, while the latter places them in memory into a deque.
In particular, the \verb|MemoryCollector| does not ``hard write'' chain states anywhere and all information contained in it is destroyed when the main that created it is terminated.
It is therefore useful in situation in which writing to a file is not needed, for instance in a main program that both runs the algorithm and computes the estimates.
Instead, the contents of a \verb|Filecollector| are permanent, because every state collected by it remains ever after the termination of the main that created it, in Protobuf form, in the corresponding file.
This approach is mandatory, for instance, if different main programs are used to run the algorithm and the estimates, for instance in the Python interface (more on this later, in section \ref{chap-py-int}).
Both collectors store the current size of the chain, i.e. the number of the stored \verb|State| objects, which is constantly updated during the run after each performed iteration, and \verb|curr_iter|, an integer that acts as a cursor, useful when reading the chain state-by-state.

\subsection{Writing and reading}
In the main program, a collector whose type is chosen at runtime is instantiated before running the algorithm, and a \verb|BaseCollector| pointer points to the collector object, exploiting polymorphism.
Then, the \verb|BaseCollector| pointer is passed to the \verb|run()| method.
Let us take a closer look at the \emph{writing} procedure in it.
In the specific case of \verb|FileCollector|, we first pass a string to the constructor, which initializes the \verb|filename| where the chain will be saved.
Then, in \verb|run()|, the \verb|start()| method creates a so-called open file description that refers to the file, as well as a stream object that writes to it via a Unix file descriptor.
After each iteration, the \verb|collect()| function is called which takes as input the current state in Protobuf object format and writes it into the file.
At the end of \verb|run()|, after all iterations have been performed, \verb|finish()| closes the file descriptor and the corresponding file.
The writing procedure is similar when using a \verb|MemoryCollector|, except that \verb|collect()| inserts the current iteration's state in Protobuf-object form into the deque. \\
Once the algorithm's run is completed, one may proceed with the density and clustering estimates.
Both of these require \emph{reading} from the collector, since they require knowledge of the entire chain of states.
Therefore, the aforementioned \verb|BaseCollector| pointer is also passed to the estimate functions, inside of which the method \verb|get_chain()| is called, which returns the whole chain in deque form.
In the case of \verb|MemoryCollector| this simply means returning the currently stored \verb|chain| protected member, while in the case of \verb|FileCollector| the chain is read state-by-state from the binary file, converted back into Protobuf format and returned as a deque. \\
In fact, two alternatives are possible for reading: the above method of using \verb|get_chain()|, and reading one state at a time directly in the estimates functions when necessary, without having to save back the whole chain. 
This is achieved using the function \verb|get_next_state()|, which returns one state at a time based on the current position given by the cursor \verb|curr_iter|, which is increased by 1 with each call.
With such an implementation, in both estimate functions' loops over the iterations, \verb|get_next_state()| is called at each round, which in turn calls the \verb|get_next()| protected method, specifically implemented for each collector, and the state relative to the current round is returned.
This is easily achieved when using a \verb|MemoryCollector|, but in the case of \verb|FileCollector|, the \verb|State| object must be read from the file itself.
However, unlike in the cases using \verb|MemoryCollector|, if the estimate functions are executed in a different source file than the one where the algorithm is run, a \verb|FileCollector| must be used, but in the second source file the information on the size of the chain and of the objects is unavailable, since the actual C++ object was destroyed when closing the first one.
This information is crucial in order to correctly read from the produced binary file.
Therefore, our library currently uses the \verb|get_chain()| method which re-creates the whole chain even from a \verb|FileCollector| instead of the state-by-state method.
In order to use the latter, one would have to store additional information about object sizes in the file itself. \\
In addition, in the cluster estimate utility, even though all dissimilarity matrices can be computed via state-by-state reading, one needs random access to retrieve the \verb|State| object corresponding to the best clustering.
In the case of \verb|FileCollector|, since the current implementation re-creates the \verb|chain| deque, one can simply access \verb|chain[i]| where \verb|i| is the iteration that minimizes the squared error.
If the above reading mode were to be implemented, one would need to use a getter \verb|get_state(unsigned int i)|, which would make necessary to re-read the file up to this iteration with multiple calls to \verb|get_state()|.
In this case, optimization may be achieved by saving the byte size of the individual Protobuf objects, so that one can recover a specific state directly by jumping at the correct location in the file without having to read and return all previous iterations.
