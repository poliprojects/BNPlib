MAIL:

Guardate in particolare i file
- pp_mix/src/python_exports.cpp
- pp_mix/interface.py
- Makefile
In particolare, in python_exports.cpp c'è l'interfaccia Python / C++. 
Visto che l'interfaccia è abbastanza "grezza", io di solito la wrappo in una
classe Python, che in questo caso è in 'interface.py'.
Invece nel Makefile c'è il comando 'generate_pybind' che genera un pacchetto
Python (ma non lo installa) con le funzioni definite nella sezione
'PYBIND11_MODULE' in python_exports.cpp
Visto che questo pacchetto non è installato, ogni volta che da un file python
lo voglio caricare devo prima aggiungere la directory dove è salvato alla
variabile di path , cioè le righe:

sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))
import pp_mix_cpp  # noqa

Per questo secondo me è importante 'wrappare' l'interfaccia Pyhton / C++ in un
unico file Python, per evitare di dover fare questa chiamata a
'sys.path.insert' svariate volte.

//////////////////////////////////////////////////////////////////////////////

SCHELETRO DI PYTHON_EXPORTS.CPP:

#include <pybind11/pybind11.h>

int foo(int i) {
	return i+1;
}

PYBIND11_MODULE(bnplib, m) {
    m.doc() = "This is a docstring for the library"

    m.def("foo", &foo, "This is a docstr for the foo() function");
}

//////////////////////////////////////////////////////////////////////////////

SCHELETRO DI INTERFACE.PY:

import os, sys
sys.path.insert(0, os.path.dirname(os.path.realpath(__file__)))
import bnplib

bnplib.foo(3)

//////////////////////////////////////////////////////////////////////////////

IN MAKEFILE:

all: generate_pybind $(SPIKES_EXECS)

generate_pybind: $(OBJS)
	$(CXX) -shared $(CFLAGS) `/usr/bin/python3.8 -m pybind11 --includes` \
		src/python_exports.cpp -o \
		bnplib`/usr/bin/python3.8-config --extension-suffix` \
		$(OBJS) $(LDLIBS) -fopenmp
