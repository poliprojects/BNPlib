model {

for (i in 1:numGroups) {
  for (j in 1:num_samples[i]) {
    y[i, j] ~ dnorm(means[rho[i], s[rho[i], i, j]], 1 / (sigma[rho[i], s[rho[i], i, j]] ^ 2))
    for (k in 1:numGroups) {
      s[k, i, j] ~ dcat(weights[k, ])
    }
  }
}

alpha0 <- 1
rho[1] <- 1
pos[1] <- 1

for (i in 2:numGroups) {
  for (j in 1:(i-1)) {
    probas[i, j] <- 1 / (i - 1 + alpha0)
  }
  probas[i, i] <- alpha0 / (i - 1 + alpha0)
  for (j in (i+1):numGroups) {
    probas[i, j] <- 0
  }
  maxRho <-  max(rho[1:(i-1)])
  pos[i] ~ dcat(probas[i, ])
  rho[i] <- ifelse(pos[i] <= maxRho, rho[pos[i]], maxRho + 1)
}

#### Dirichlet Processes ####
sigmaH ~ dunif(0, 1.5)
tauH <- 1 / sigmaH^2


# atoms
for (i in 1:numGroups) {
  for (h in 1:H) {
    sigma[i, h] ~ dunif(0, 2)
    means[i, h] ~ dnorm(mu0[i], 1 / (sigma[i, h]^2 * lambda[i]))
  }
}

for (i in 1:numGroups) {
  lambda[i] ~ dunif(0, 2)
  mu0[i] ~ dnorm(0, tauH)
  gam[i] <- 0.5 + gam0[i]
  gam0[i] ~ dgamma(2, 2)
}

# weights
for (i in 1:numGroups) {
  for (h in 1:(H-1)) {
    v[i, h] ~ dbeta(1, gam[i])
  }
}

for (i in 1:numGroups) {
  weights[i, 1] <- v[i, 1]
  for (h in 2 : (H-1)) {
    weights[i, h] <- v[i, h] * (1 - v[i, h-1]) * weights[i, h-1]/v[i, h-1]
  }
  weights[i, H] <- 1 - sum(weights[i, 1:(H-1)])
}

} # end model
