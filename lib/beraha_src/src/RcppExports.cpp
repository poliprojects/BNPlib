// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppArmadillo.h>
#include <Rcpp.h>

using namespace Rcpp;

// runGibbs
Rcpp::List runGibbs(std::string model, const Rcpp::List& data_, int numIter, int burnIn, int warmup, int thin, int numComponents, int log_every, bool usePseudoPrior);
RcppExport SEXP _SemiHDP_runGibbs(SEXP modelSEXP, SEXP data_SEXP, SEXP numIterSEXP, SEXP burnInSEXP, SEXP warmupSEXP, SEXP thinSEXP, SEXP numComponentsSEXP, SEXP log_everySEXP, SEXP usePseudoPriorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type model(modelSEXP);
    Rcpp::traits::input_parameter< const Rcpp::List& >::type data_(data_SEXP);
    Rcpp::traits::input_parameter< int >::type numIter(numIterSEXP);
    Rcpp::traits::input_parameter< int >::type burnIn(burnInSEXP);
    Rcpp::traits::input_parameter< int >::type warmup(warmupSEXP);
    Rcpp::traits::input_parameter< int >::type thin(thinSEXP);
    Rcpp::traits::input_parameter< int >::type numComponents(numComponentsSEXP);
    Rcpp::traits::input_parameter< int >::type log_every(log_everySEXP);
    Rcpp::traits::input_parameter< bool >::type usePseudoPrior(usePseudoPriorSEXP);
    rcpp_result_gen = Rcpp::wrap(runGibbs(model, data_, numIter, burnIn, warmup, thin, numComponents, log_every, usePseudoPrior));
    return rcpp_result_gen;
END_RCPP
}
// predictiveSamples
arma::mat predictiveSamples(std::string model, const Rcpp::List& chains);
RcppExport SEXP _SemiHDP_predictiveSamples(SEXP modelSEXP, SEXP chainsSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type model(modelSEXP);
    Rcpp::traits::input_parameter< const Rcpp::List& >::type chains(chainsSEXP);
    rcpp_result_gen = Rcpp::wrap(predictiveSamples(model, chains));
    return rcpp_result_gen;
END_RCPP
}
// runNormalConjugateGibbs
Rcpp::List runNormalConjugateGibbs(const Rcpp::List& data_, int numIter, int burnIn, int warmup, int thin, int numComponents, int log_every, bool usePseudoPrior);
RcppExport SEXP _SemiHDP_runNormalConjugateGibbs(SEXP data_SEXP, SEXP numIterSEXP, SEXP burnInSEXP, SEXP warmupSEXP, SEXP thinSEXP, SEXP numComponentsSEXP, SEXP log_everySEXP, SEXP usePseudoPriorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::List& >::type data_(data_SEXP);
    Rcpp::traits::input_parameter< int >::type numIter(numIterSEXP);
    Rcpp::traits::input_parameter< int >::type burnIn(burnInSEXP);
    Rcpp::traits::input_parameter< int >::type warmup(warmupSEXP);
    Rcpp::traits::input_parameter< int >::type thin(thinSEXP);
    Rcpp::traits::input_parameter< int >::type numComponents(numComponentsSEXP);
    Rcpp::traits::input_parameter< int >::type log_every(log_everySEXP);
    Rcpp::traits::input_parameter< bool >::type usePseudoPrior(usePseudoPriorSEXP);
    rcpp_result_gen = Rcpp::wrap(runNormalConjugateGibbs(data_, numIter, burnIn, warmup, thin, numComponents, log_every, usePseudoPrior));
    return rcpp_result_gen;
END_RCPP
}
// runSemiHdpBlockedGibbs
Rcpp::List runSemiHdpBlockedGibbs(const Rcpp::List& data_, int numIter, int burnIn, int warmup, int thin, int numComponents, int log_every, bool usePseudoPrior);
RcppExport SEXP _SemiHDP_runSemiHdpBlockedGibbs(SEXP data_SEXP, SEXP numIterSEXP, SEXP burnInSEXP, SEXP warmupSEXP, SEXP thinSEXP, SEXP numComponentsSEXP, SEXP log_everySEXP, SEXP usePseudoPriorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::List& >::type data_(data_SEXP);
    Rcpp::traits::input_parameter< int >::type numIter(numIterSEXP);
    Rcpp::traits::input_parameter< int >::type burnIn(burnInSEXP);
    Rcpp::traits::input_parameter< int >::type warmup(warmupSEXP);
    Rcpp::traits::input_parameter< int >::type thin(thinSEXP);
    Rcpp::traits::input_parameter< int >::type numComponents(numComponentsSEXP);
    Rcpp::traits::input_parameter< int >::type log_every(log_everySEXP);
    Rcpp::traits::input_parameter< bool >::type usePseudoPrior(usePseudoPriorSEXP);
    rcpp_result_gen = Rcpp::wrap(runSemiHdpBlockedGibbs(data_, numIter, burnIn, warmup, thin, numComponents, log_every, usePseudoPrior));
    return rcpp_result_gen;
END_RCPP
}
// runSemiHdpMarginal
Rcpp::List runSemiHdpMarginal(const Rcpp::List& data_, int numIter, int burnIn, int warmup, int thin, int log_every, bool usePseudoPrior);
RcppExport SEXP _SemiHDP_runSemiHdpMarginal(SEXP data_SEXP, SEXP numIterSEXP, SEXP burnInSEXP, SEXP warmupSEXP, SEXP thinSEXP, SEXP log_everySEXP, SEXP usePseudoPriorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const Rcpp::List& >::type data_(data_SEXP);
    Rcpp::traits::input_parameter< int >::type numIter(numIterSEXP);
    Rcpp::traits::input_parameter< int >::type burnIn(burnInSEXP);
    Rcpp::traits::input_parameter< int >::type warmup(warmupSEXP);
    Rcpp::traits::input_parameter< int >::type thin(thinSEXP);
    Rcpp::traits::input_parameter< int >::type log_every(log_everySEXP);
    Rcpp::traits::input_parameter< bool >::type usePseudoPrior(usePseudoPriorSEXP);
    rcpp_result_gen = Rcpp::wrap(runSemiHdpMarginal(data_, numIter, burnIn, warmup, thin, log_every, usePseudoPrior));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_SemiHDP_runGibbs", (DL_FUNC) &_SemiHDP_runGibbs, 9},
    {"_SemiHDP_predictiveSamples", (DL_FUNC) &_SemiHDP_predictiveSamples, 2},
    {"_SemiHDP_runNormalConjugateGibbs", (DL_FUNC) &_SemiHDP_runNormalConjugateGibbs, 8},
    {"_SemiHDP_runSemiHdpBlockedGibbs", (DL_FUNC) &_SemiHDP_runSemiHdpBlockedGibbs, 8},
    {"_SemiHDP_runSemiHdpMarginal", (DL_FUNC) &_SemiHDP_runSemiHdpMarginal, 7},
    {NULL, NULL, 0}
};

RcppExport void R_init_SemiHDP(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
